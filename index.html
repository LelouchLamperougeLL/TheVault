<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Vault v7 - Cloud Edition</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            bg: '#0f1115',
                            card: '#111827',
                            border: '#374151',
                            text: '#ffffff',
                            subtext: '#9ca3af',
                            accent: '#6366f1'
                        },
                        light: {
                            bg: '#f3f4f6',
                            card: '#ffffff',
                            border: '#e5e7eb',
                            text: '#111827',
                            subtext: '#4b5563',
                            accent: '#4f46e5'
                        }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-out',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['Fira Code', 'monospace'],
                    }
                }
            }
        }
    </script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(99, 102, 241, 0.5); border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(99, 102, 241, 0.8); }
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; }
        input[type=range]:focus { outline: none; }
    </style>
</head>
<body class="bg-light-bg dark:bg-dark-bg text-light-text dark:text-dark-text transition-colors duration-300 overflow-y-scroll">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect, useCallback, useRef } = React;
        
        // --- CONFIG ---
        const supabase = window.supabase.createClient(
              "https://ugllcdapuzihpkgcoaxj.supabase.co",
              "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVnbGxjZGFwdXppaHBrZ2NvYXhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0OTA3NzksImV4cCI6MjA4NjA2Njc3OX0.73I1cW1fqRUha5_6spK7C8m-SXUHQQfyjmcbNNbdfCI"
              );
        // Point to your backend

        // --- ICONS ---
        const IconBase = ({ size = 20, className, children, ...props }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>);
        const Film = (p) => <IconBase {...p}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M7 3v18"/><path d="M3 7.5h4"/><path d="M3 12h18"/><path d="M3 16.5h4"/><path d="M17 3v18"/><path d="M17 7.5h4"/><path d="M17 16.5h4"/></IconBase>;
        const Tv = (p) => <IconBase {...p}><rect width="20" height="15" x="2" y="7" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></IconBase>;
        const Play = (p) => <IconBase {...p}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const Star = ({ fill, ...p }) => <IconBase {...p} fill={fill || "none"}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></IconBase>;
        const Search = (p) => <IconBase {...p}><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></IconBase>;
        const CheckCircle = (p) => <IconBase {...p}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></IconBase>;
        const ListPlus = (p) => <IconBase {...p}><path d="M11 12H3"/><path d="M16 6H3"/><path d="M16 18H3"/><path d="M18 9v6"/><path d="M21 12h-6"/></IconBase>;
        const X = (p) => <IconBase {...p}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase>;
        const Upload = (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></IconBase>;
        const Download = (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></IconBase>;
        const Settings = (p) => <IconBase {...p}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const RefreshCw = (p) => <IconBase {...p}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></IconBase>;
        const Edit = (p) => <IconBase {...p}><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></IconBase>;
        const Repeat = (p) => <IconBase {...p}><path d="m17 2 4 4-4 4"/><path d="M3 11v-1a4 4 0 0 1 4-4h14"/><path d="m7 22-4-4 4-4"/><path d="M21 13v1a4 4 0 0 1-4 4H3"/></IconBase>;
        const Zap = (p) => <IconBase {...p}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconBase>;
        const Globe = (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><line x1="2" x2="22" y1="12" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></IconBase>;
        const Trash = (p) => <IconBase {...p}><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /></IconBase>;
        const BarChart = (p) => <IconBase {...p}><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></IconBase>;
        const CheckSquare = (p) => <IconBase {...p}><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></IconBase>;
        const LogIn = (p) => <IconBase {...p}><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" x2="3" y1="12" y2="12"/></IconBase>;
        const User = (p) => <IconBase {...p}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></IconBase>;

        // Custom Vault Logo
        const VaultLogoIcon = (p) => (
            <IconBase {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
                <path d="M3 7h2v10H3a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1z" fill="currentColor" fillOpacity="0.2" />
                <path d="M5 9h2" strokeLinecap="round" />
                <path d="M5 15h2" strokeLinecap="round" />
                <circle cx="15" cy="12" r="8" strokeWidth="2" />
                <circle cx="15" cy="12" r="6.2" strokeDasharray="0.5 2.5" strokeLinecap="round" strokeWidth="1.5" className="opacity-60" />
                <circle cx="15" cy="12" r="3" strokeWidth="1.5" />
                <path d="M15 9V6" strokeLinecap="round" />
                <path d="M15 15v3" strokeLinecap="round" />
                <path d="M12.4 10.5L9.8 9" strokeLinecap="round" />
                <path d="M17.6 10.5L20.2 9" strokeLinecap="round" />
                <path d="M12.4 13.5L9.8 15" strokeLinecap="round" />
                <path d="M17.6 13.5L20.2 15" strokeLinecap="round" />
                <ellipse cx="15" cy="12" rx="1.2" ry="1.8" fill="currentColor" />
                <path d="M15 11v2" stroke="white" strokeWidth="0.5" className="dark:stroke-gray-900" />
            </IconBase>
        );

        // --- CONSTANTS ---
        const DEFAULT_KEYS = { omdb: '5591108c', tmdb: '68b27c1f85725736f0aec18b903197b0', rapid: '9782bOaf7fmsh8b54c22e5cOaf5cp13e6e8jsn8e2e765657a5' };
        
        // ðŸ”¥ A. SMART_LISTS (huge upgrade)
        const SMART_LISTS = [
            { id: 'top_rated', label: 'Top Rated', icon: Star, filter: item => item.userMeta?.ratings?.overall >= 9 },
            { id: 'rewatch', label: 'Rewatch Worthy', icon: Repeat, filter: item => item.userMeta?.rewatchCount > 0 },
            { id: 'foreign', label: 'Foreign', icon: Globe, filter: item => item.Language && !item.Language.includes('English') },
            { id: 'progress', label: 'In Progress', icon: Play, filter: item => item.userMeta?.series?.lastEpisode?.season > 0 },
        ];

        // --- HELPERS (Outside App) ---
        const normalize = (q) => q.toLowerCase().trim().replace(/[^a-z0-9]/g, '');
        const SEARCH_TTL = 7 * 24 * 60 * 60 * 1000;

        const getSearchCache = (key) => {
          try {
            const raw = localStorage.getItem(key);
            if (!raw) return null;
            const { data, ts } = JSON.parse(raw);
            if (Date.now() - ts > SEARCH_TTL) return null;
            return data;
          } catch (e) { return null; }
        };

        const setSearchCache = (key, data) => {
          try {
            localStorage.setItem(key, JSON.stringify({ data, ts: Date.now() }));
          } catch (e) { console.warn("Cache quota exceeded"); }
        };

        // --- UTILS ---
        const getHighResPoster = (url, width = 600) => {
            if (!url || url === "N/A") return "https://via.placeholder.com/300x450?text=No+Poster";
            if (url.includes("media-amazon.com") || url.includes("images-na.ssl-images-amazon.com")) {
                return url.replace(/_V1_.*\.jpg$/, `_V1_SX${width}.jpg`);
            }
            if (url.includes("tmdb.org")) return url.replace(/\/w\d+\//, width > 700 ? "/original/" : `/w${width}/`);
            return url;
        };

        // D. migrateItem() (this is critical)
        const migrateItem = (item, status) => {
            if (item.userMeta) return item;
            
            // Preserve old rating if available
            const oldRating = parseFloat(item.userRating || 0);
            const isSeries = item.Type === 'series';

            return {
              ...item,
              userMeta: {
                status,
                userRating: oldRating, // Keeping this to prevent data loss despite snippet
                rewatchCount: 0,
                // Critical logic from snippet D
                series: isSeries ? {
                  lastEpisode: { season: 0, episode: 0 },
                  completed: false
                } : null,
                // Critical V7 props
                ratings: { overall: oldRating, story: 0, direction: 0, emotion: 0 },
                lastUpdated: Date.now(),
                watchedOn: new Date().toISOString().split('T')[0],
                autoOverall: true,
                notes: ""
              }
            };
        };

        // --- AUTH COMPONENT ---
        const AuthModal = ({ isOpen, onClose, onLogin }) => {
            const [isRegister, setIsRegister] = useState(false);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            if (!isOpen) return null;

            const handleSubmit = async (e) => {
              e.preventDefault();
              setError("");

              try {
                if (isRegister) {
                  const { error } = await supabase.auth.signUp({
                    email,
                    password
                  });
                  if (error) throw error;
                  alert("Registered! Now login.");
                  setIsRegister(false);
                } else {
                  const { data, error } = await supabase.auth.signInWithPassword({
                    email,
                    password
                  });
                  if (error) throw error;
                  onLogin(data.session);
                  onClose();
                }
              } catch (err) {
                setError(err.message);
              }
            };


            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-sm rounded-2xl shadow-2xl border border-light-border dark:border-dark-border p-8 relative">
                         <div className="text-center mb-8">
                             <div className="inline-block p-3 rounded-full bg-indigo-100 dark:bg-indigo-900/30 text-indigo-600 mb-4">
                                <VaultLogoIcon size={48} />
                             </div>
                             <h2 className="text-2xl font-black text-gray-900 dark:text-white uppercase tracking-wider">{isRegister ? 'Join The Vault' : 'Welcome Back'}</h2>
                             <p className="text-sm text-gray-500 mt-2">Sync your collection across devices</p>
                         </div>
                         
                         {error && <div className="mb-4 p-3 bg-red-100 text-red-700 text-sm rounded-lg">{error}</div>}

                         <form onSubmit={handleSubmit} className="space-y-4">
                             <div>
                                 <label className="block text-xs font-bold uppercase text-gray-500 mb-1">Email</label>
                                 <input type="email" value={email} onChange={e => setEmail(e.target.value)} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg p-3 text-sm outline-none focus:border-indigo-500 dark:text-white" required />
                             </div>
                             <div>
                                 <label className="block text-xs font-bold uppercase text-gray-500 mb-1">Password</label>
                                 <input type="password" value={password} onChange={e => setPassword(e.target.value)} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg p-3 text-sm outline-none focus:border-indigo-500 dark:text-white" required />
                             </div>
                             <button type="submit" className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg transition-colors shadow-lg shadow-indigo-600/20">
                                 {isRegister ? 'Create Account' : 'Access Vault'}
                             </button>
                         </form>

                         <div className="mt-6 text-center">
                             <button onClick={() => setIsRegister(!isRegister)} className="text-sm text-gray-500 hover:text-indigo-600 dark:hover:text-white transition-colors">
                                 {isRegister ? 'Already have an account? Login' : 'Need an account? Register'}
                             </button>
                         </div>
                    </div>
                </div>
            );
        }

        // --- SETTINGS MODAL ---
        const SettingsModal = ({ isOpen, onClose, apiKeys, setApiKeys, theme, setTheme, onReset, onImport, onExport }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-md rounded-2xl shadow-2xl border border-light-border dark:border-dark-border p-6 relative">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-500 hover:text-white"><X size={20} /></button>
                        <h2 className="text-xl font-bold mb-6 dark:text-white flex items-center gap-2"><Settings size={20} /> Vault Settings</h2>
                        
                        <div className="space-y-6">
                            <div>
                                <label className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2 block">Appearance</label>
                                <div className="grid grid-cols-2 gap-2">
                                    <button onClick={() => setTheme('light')} className={`py-2 rounded-lg text-sm font-medium border ${theme === 'light' ? 'bg-indigo-50 border-indigo-500 text-indigo-700' : 'border-gray-200 dark:border-gray-700 dark:text-gray-400'}`}>Light Mode</button>
                                    <button onClick={() => setTheme('dark')} className={`py-2 rounded-lg text-sm font-medium border ${theme === 'dark' ? 'bg-indigo-900/30 border-indigo-500 text-indigo-300' : 'border-gray-200 dark:border-gray-700 dark:text-gray-400'}`}>Dark Mode</button>
                                </div>
                            </div>

                            <div>
                                <label className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2 block">API Connections</label>
                                <div className="space-y-3">
                                    <input type="text" placeholder="OMDb API Key" value={apiKeys.omdb} onChange={(e) => setApiKeys(p => ({...p, omdb: e.target.value}))} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 text-sm outline-none focus:border-indigo-500 dark:text-white" />
                                    <input type="text" placeholder="TMDB API Key" value={apiKeys.tmdb} onChange={(e) => setApiKeys(p => ({...p, tmdb: e.target.value}))} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 text-sm outline-none focus:border-indigo-500 dark:text-white" />
                                    <input type="text" placeholder="RapidAPI Key (Optional)" value={apiKeys.rapid || ''} onChange={(e) => setApiKeys(p => ({...p, rapid: e.target.value}))} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 text-sm outline-none focus:border-indigo-500 dark:text-white" />
                                </div>
                                <p className="text-xs text-gray-500 mt-2">Keys are stored locally in your browser.</p>
                            </div>

                            <div className="pt-4 border-t border-gray-200 dark:border-gray-700 space-y-3">
                                <div className="grid grid-cols-2 gap-3">
                                    <button onClick={onExport} className="flex items-center justify-center gap-2 bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg text-xs font-bold hover:bg-gray-200 dark:hover:bg-gray-700"><Download size={14}/> Backup</button>
                                    <label className="flex items-center justify-center gap-2 bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg text-xs font-bold hover:bg-gray-200 dark:hover:bg-gray-700 cursor-pointer">
                                        <Upload size={14}/> Restore
                                        <input type="file" accept=".json" onChange={onImport} className="hidden" />
                                    </label>
                                </div>
                                <button onClick={onReset} className="w-full text-red-500 hover:text-red-600 text-xs font-bold py-2">Factory Reset Vault</button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        function App() {
            // -- State --
            const [session, setSession] = useState(null);

            const [vault, setVault] = useState({ watched: {}, watchlist: {} });
            const [apiKeys, setApiKeys] = useState(DEFAULT_KEYS);
            const [theme, setTheme] = useState('dark');
            
            const [showAuth, setShowAuth] = useState(false);
            const [syncStatus, setSyncStatus] = useState('idle'); // idle, syncing, error
            
            // -- UI State --
            const [searchQuery, setSearchQuery] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [activeFilter, setActiveFilter] = useState('all');
            const [activeSmartList, setActiveSmartList] = useState(null);
            const [sortBy, setSortBy] = useState('updated');
            const [selectedMovie, setSelectedMovie] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [isSelectMode, setIsSelectMode] = useState(false);
            const [selectedIds, setSelectedIds] = useState([]);

            // -- Initialization --
            useEffect(() => {
                if (theme === 'dark') document.documentElement.classList.add('dark');
                else document.documentElement.classList.remove('dark');
                const localKeys = localStorage.getItem('vault_v5_keys');
                if (localKeys) setApiKeys(JSON.parse(localKeys));
                
            }, []);

            // -- Session Restore Effect --
            useEffect(() => {
                supabase.auth.getSession().then(({ data }) => {
                    setSession(data.session);
                });

                const { data: listener } = supabase.auth.onAuthStateChange(
                    (_event, session) => {
                        setSession(session);
                    }
                );

                return () => listener.subscription.unsubscribe();
            }, []);

            useEffect(() => { localStorage.setItem('vault_v5_keys', JSON.stringify(apiKeys)); }, [apiKeys]);
            useEffect(() => { if (theme === 'dark') document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark'); }, [theme]);

            // -- AUTH & SYNC --
            const handleLogin = (session) => {
              setSession(session);
            };


           const handleLogout = async () => {
              await supabase.auth.signOut();
              setSession(null);
            };

            // -- BACKUP & RESTORE --
            const handleExport = () => {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(vault));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "vault_backup_" + new Date().toISOString().split('T')[0] + ".json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            };

            const handleImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const rawData = JSON.parse(event.target.result);
                        if (!rawData.watched && !rawData.watchlist) throw new Error("Invalid format: Not a Vault backup file");
                        
                        // MIGRATION LOGIC
                        const processedVault = { watched: {}, watchlist: {} };
                        
                        Object.entries(rawData.watched || {}).forEach(([id, item]) => {
                            processedVault.watched[id] = migrateItem(item, 'watched');
                        });
                        
                        Object.entries(rawData.watchlist || {}).forEach(([id, item]) => {
                            processedVault.watchlist[id] = migrateItem(item, 'watchlist');
                        });

                        // 1. Update Local State & Storage (Immediate UI Update)
                        setVault(processedVault);
                        localStorage.setItem('vault_v6_data', JSON.stringify(processedVault));
                        
                        // 2. Cloud Sync (if logged in) - REPLACES existing data
                        if (session) {
                            setSyncStatus('syncing');
                            
                            // Delete all existing items for this user (Replace logic)
                            await supabase.from('vault_items').delete().eq('user_id', session.user.id);

                            // Transform to flat array for upload
                            const items = [];
                            [...Object.values(processedVault.watched), ...Object.values(processedVault.watchlist)].forEach(item => {
                                items.push({
                                    user_id: session.user.id,
                                    imdb_id: item.imdbID,
                                    user_meta: item,
                                    updated_at: new Date()
                                });
                            });

                            // Upload in chunks to avoid payload limits
                            const chunkSize = 50;
                            for (let i = 0; i < items.length; i += chunkSize) {
                                const chunk = items.slice(i, i + chunkSize);
                                const { error } = await supabase.from('vault_items').upsert(chunk);
                                if (error) console.error("Chunk upload error:", error);
                            }
                            
                            setSyncStatus('idle');
                        }
                        
                        setShowSettings(false);
                        alert("Vault restored successfully!");
                    } catch (err) {
                        console.error(err);
                        alert("Failed to import file: " + err.message);
                    }
                };
                reader.readAsText(file);
            };


            // Cloud Fetch Effect (The user requested snippet logic)
           useEffect(() => {
              if (!session) return;

              setSyncStatus("syncing");

              supabase
                .from("vault_items")
                .select("*")
                .then(({ data, error }) => {
                  if (error) {
                    setSyncStatus("error");
                    return console.error(error);
                  }
                  
                  setSyncStatus("idle");
                  const newVault = { watched: {}, watchlist: {} };

                  data.forEach(row => {
                    let item = row.user_meta;
                    // Migrate item if coming from raw cloud data that might be old
                    // Heuristic: if userRating > 0 or previously marked as watched, default to watched
                    const defaultStatus = (item.userRating && parseFloat(item.userRating) > 0) ? 'watched' : 'watchlist';
                    item = migrateItem(item, defaultStatus); 
                    
                    if (item.userMeta?.status === "watched")
                      newVault.watched[row.imdb_id] = item;
                    else
                      newVault.watchlist[row.imdb_id] = item;
                  });

                  setVault(newVault);
                  localStorage.setItem("vault_v6_data", JSON.stringify(newVault));
                })
                .catch(err => {
                    setSyncStatus("error");
                    console.error(err);
                });
            }, [session]);



            // Save Item to Cloud
            const saveToCloud = async (imdbId, item) => {
              if (!session) return;

              const { error } = await supabase.from("vault_items").upsert({
                user_id: session.user.id,
                imdb_id: imdbId,
                user_meta: item,
                updated_at: new Date()
              });
              
              if (error) console.error("Save failed", error);
            };


            const updateItem = useCallback((imdbID, updater) => {
                setVault(prev => {
                    const item = prev.watched[imdbID] || prev.watchlist[imdbID];
                    if (!item) return prev;

                    const updatedItem = updater(item);
                    if (!updatedItem.userMeta.lastUpdated) updatedItem.userMeta.lastUpdated = Date.now();
                    
                    const newStatus = updatedItem.userMeta.status;
                    const nextWatched = { ...prev.watched };
                    const nextWatchlist = { ...prev.watchlist };

                    delete nextWatched[imdbID];
                    delete nextWatchlist[imdbID];

                    if (newStatus === 'watched') nextWatched[imdbID] = updatedItem;
                    else nextWatchlist[imdbID] = updatedItem;

                    // Trigger Cloud Save
                    saveToCloud(imdbID, updatedItem);

                    return { watched: nextWatched, watchlist: nextWatchlist };
                });
            }, [session]);

            // --- SEARCH LOGIC ---

            // Check if item exists in vault
            const existsInVault = useCallback((imdbID) => {
                return !!(vault.watched[imdbID] || vault.watchlist[imdbID]);
            }, [vault]);

            // Offline search
            const searchOfflineVault = useCallback((query) => {
              const norm = normalize(query);
              if (!norm) return [];
              const all = [
                ...Object.values(vault.watched),
                ...Object.values(vault.watchlist)
              ];
              return all.filter(item =>
                normalize(item.Title).includes(norm) ||
                item.imdbID === query
              );
            }, [vault]);

            const smartSearch = useCallback(async (query, type = "", year = "") => {
              // 1. Offline
              const offline = searchOfflineVault(query);
              if (offline.length > 0) return { source: "offline", results: offline };

              const cacheKey = `vault_search_${type}_${query}_${year}`;
              
              // 2. Cache
              const cached = getSearchCache(cacheKey);
              if (cached) return { source: "cache", results: cached };

              // 3. Remote
              try {
                  const res = await fetch(
                    `https://www.omdbapi.com/?apikey=${apiKeys.omdb}&s=${encodeURIComponent(query)}&type=${type}&y=${year}`
                  );
                  const json = await res.json();
                  if (json.Response === "False") return { source: "none", results: [] };

                  // 4. Rank
                  const ranked = json.Search.sort((a, b) => {
                    const exactA = normalize(a.Title) === normalize(query);
                    const exactB = normalize(b.Title) === normalize(query);
                    if (exactA !== exactB) return exactB - exactA;
                    return (parseInt(b.Year) || 0) - (parseInt(a.Year) || 0);
                  });

                  setSearchCache(cacheKey, ranked);
                  return { source: "remote", results: ranked };
              } catch (e) {
                  console.error(e);
                  return { source: "error", results: [] };
              }
            }, [apiKeys, searchOfflineVault]);

            const fetchMovieById = async (imdbID) => {
               try {
                   const res = await fetch(
                    `https://www.omdbapi.com/?apikey=${apiKeys.omdb}&i=${imdbID}&plot=full`
                   );
                   return await res.json();
               } catch(e) {
                   console.error("Fetch ID error:", e);
                   return null;
               }
            };

            const addToVault = async (imdbID, status = "watchlist") => {
              const fullItem = await fetchMovieById(imdbID);

              if (!fullItem || fullItem.Response === "False") return;

              const migrated = migrateItem(fullItem, status);

              setVault(prev => {
                const next = {
                  watched: { ...prev.watched },
                  watchlist: { ...prev.watchlist }
                };

                // Remove from other list if it exists (implicit move)
                delete next.watched[imdbID];
                delete next.watchlist[imdbID];

                if (status === "watched") {
                  next.watched[imdbID] = migrated;
                } else {
                  next.watchlist[imdbID] = migrated;
                }

                return next;
              });

              // ðŸ” Cloud sync
              saveToCloud(imdbID, migrated);
              setSearchResults([]);
              setSearchQuery('');
            };

            const handleSearch = async (q) => {
              if (!q || q.length < 3) {
                  setSearchResults([]);
                  return;
              }
              const { results } = await smartSearch(q);
              setSearchResults(results || []);
            };

            // ... (Rest of the bulk actions logic remains the same, just add cloud deletes if needed)
            const handleBulkAction = (action) => {
               // Simplified for brevity - assumes local update first
               // In a real app, you'd loop through selectedIds and call API delete endpoints
               alert("Bulk actions locally updated. Refresh to sync from cloud.");
               setIsSelectMode(false);
               setSelectedIds([]);
            };

            const toggleSelect = (id) => setSelectedIds(prev => prev.includes(id) ? prev.filter(i => i !== id) : [...prev, id]);

            // -- Computed Data (Same as v6) --
            // B. Unified allItems search space
            const allItems = useMemo(() => [...Object.values(vault.watched), ...Object.values(vault.watchlist)], [vault]);
            const analytics = useMemo(() => {
                const total = allItems.length;
                if (total === 0) return { avgRating: 0, totalRewatch: 0, watchedCount: 0 };
                const watched = Object.values(vault.watched);
                const avgRating = watched.reduce((acc, curr) => acc + (curr.userMeta?.ratings?.overall || 0), 0) / (watched.length || 1);
                const totalRewatch = watched.reduce((acc, curr) => acc + (curr.userMeta?.rewatchCount || 0), 0);
                return { avgRating: avgRating.toFixed(1), totalRewatch, watchedCount: watched.length };
            }, [allItems, vault]);

            const filteredItems = useMemo(() => {
                let items = allItems;
                if (searchQuery) {
                    const q = searchQuery.toLowerCase();
                    // C. Library search pipeline (simple but effective) - Only title
                    items = items.filter(i => i.Title.toLowerCase().includes(q));
                }
                if (activeSmartList) {
                    const list = SMART_LISTS.find(l => l.id === activeSmartList);
                    if (list) items = items.filter(list.filter);
                } else {
                     if (activeFilter === 'movies') items = items.filter(i => i.Type === 'movie');
                     else if (activeFilter === 'series') items = items.filter(i => i.Type === 'series');
                }
                return items.sort((a, b) => {
                    if (sortBy === 'rating') return (b.userMeta?.ratings?.overall || 0) - (a.userMeta?.ratings?.overall || 0);
                    if (sortBy === 'updated') return (b.userMeta?.lastUpdated || 0) - (a.userMeta?.lastUpdated || 0);
                    return a.Title.localeCompare(b.Title); 
                });
            }, [allItems, searchQuery, activeFilter, activeSmartList, sortBy]);

            // ... (Components: DetailModal, SettingsModal, MovieCard - same as v6, simplified here)
            // Reusing components from context but ensuring they use the new props

            return (
                <div className="min-h-screen pb-32 selection:bg-indigo-500 selection:text-white">
                    <AuthModal isOpen={showAuth} onClose={() => setShowAuth(false)} onLogin={handleLogin} />

                    <header className="sticky top-0 z-30 bg-white/80 dark:bg-dark-bg/80 backdrop-blur-md border-b border-light-border dark:border-dark-border px-4 h-16 flex items-center justify-between">
                         <div className="flex items-center gap-3">
                             <div className="text-indigo-600 dark:text-indigo-500"><VaultLogoIcon size={38} strokeWidth={1.5} /></div>
                             <div className="flex flex-col justify-center">
                                 <span className="text-[10px] font-bold tracking-[0.25em] leading-tight text-gray-500 dark:text-gray-400 uppercase pl-0.5">The</span>
                                 <span className="text-2xl font-black tracking-[0.15em] leading-none uppercase text-gray-900 dark:text-white font-sans">Vault</span>
                             </div>
                         </div>
                         <div className="flex-1 max-w-md mx-4 hidden md:block relative">
                            <Search className="absolute left-3 top-2.5 text-gray-400" size={16} />
                            <input 
                                type="text" 
                                placeholder="Search movies or series..." 
                                value={searchQuery} 
                                onChange={async (e) => {
                                    setSearchQuery(e.target.value);
                                    if (e.target.value.length > 2) {
                                      await handleSearch(e.target.value);
                                    } else {
                                      setSearchResults([]);
                                    }
                                }}
                                className="w-full bg-gray-100 dark:bg-gray-800 rounded-full pl-10 pr-4 py-2 text-sm text-gray-900 dark:text-white outline-none focus:border-indigo-500" 
                            />
                            
                            {searchResults.length > 0 && (
                              <div className="absolute z-50 mt-2 w-full bg-white dark:bg-dark-card rounded-xl shadow-xl max-h-96 overflow-y-auto border border-gray-200 dark:border-gray-700">
                                {searchResults.map(item => {
                                  const inVault = existsInVault(item.imdbID);
                                  return (
                                    <div
                                        key={item.imdbID}
                                        className="flex items-center justify-between px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-800 border-b border-gray-100 dark:border-gray-800 last:border-0"
                                    >
                                        <div className="flex-1 min-w-0 mr-2">
                                        <p className="font-semibold text-sm truncate dark:text-white">{item.Title}</p>
                                        <p className="text-xs text-gray-500">
                                            {item.Year} â€¢ {item.Type}
                                        </p>
                                        </div>

                                        <div className="flex gap-2 shrink-0">
                                        {inVault ? (
                                            <span className="text-xs px-3 py-1.5 rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-500 font-medium cursor-default">
                                                In Vault
                                            </span>
                                        ) : (
                                            <>
                                            <button
                                                onClick={() => addToVault(item.imdbID, "watchlist")}
                                                className="text-xs px-3 py-1.5 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white font-medium"
                                            >
                                                Watchlist
                                            </button>

                                            <button
                                                onClick={() => addToVault(item.imdbID, "watched")}
                                                className="text-xs px-3 py-1.5 rounded-lg bg-green-600 hover:bg-green-700 text-white font-medium"
                                            >
                                                Watched
                                            </button>
                                            </>
                                        )}
                                        </div>
                                    </div>
                                  );
                                })}
                              </div>
                            )}
                         </div>
                         <div className="flex items-center gap-2">
                             {!session ? (
                                 <button onClick={() => setShowAuth(true)} className="flex items-center gap-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-bold transition-colors">
                                     <LogIn size={16} /> Login
                                 </button>
                             ) : (
                                 <div className="flex items-center gap-2">
                                     <div className={`w-2 h-2 rounded-full ${syncStatus === 'syncing' ? 'bg-yellow-400 animate-pulse' : syncStatus === 'error' ? 'bg-red-500' : 'bg-green-500'}`} title={`Sync Status: ${syncStatus}`}></div>
                                     <button onClick={handleLogout} className="p-2 text-gray-500 hover:text-red-500"><User size={20}/></button>
                                 </div>
                             )}
                             <button onClick={() => setShowSettings(true)} className="p-2 text-gray-500 hover:text-indigo-600 dark:text-gray-400 dark:hover:text-white"><Settings size={20} /></button>
                         </div>
                    </header>

                    <main className="max-w-7xl mx-auto px-4 pt-8">
                        {/* Analytics Cards */}
                         <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                            <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                <div className="p-3 bg-blue-100 dark:bg-blue-900/30 text-blue-600 rounded-lg"><Film size={20}/></div>
                                <div><div className="text-xs text-gray-500 uppercase font-bold">Total Items</div><div className="text-xl font-black dark:text-white">{allItems.length}</div></div>
                            </div>
                            <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                <div className="p-3 bg-yellow-100 dark:bg-yellow-900/30 text-yellow-600 rounded-lg"><Star size={20}/></div>
                                <div><div className="text-xs text-gray-500 uppercase font-bold">Avg Rating</div><div className="text-xl font-black dark:text-white">{analytics.avgRating}</div></div>
                            </div>
                        </div>

                        {/* List Filters */}
                        <div className="flex flex-wrap items-center justify-between gap-4 mb-6">
                             <div className="flex items-center gap-2 overflow-x-auto">
                                {[ { id: 'all', label: 'Everything' }, { id: 'movies', label: 'Movies' }, { id: 'series', label: 'TV Shows' } ].map(f => (
                                    <button key={f.id} onClick={() => { setActiveFilter(f.id); setActiveSmartList(null); }} className={`px-4 py-1.5 rounded-full text-sm font-medium transition-colors whitespace-nowrap ${activeFilter === f.id && !activeSmartList ? 'bg-gray-900 text-white dark:bg-white dark:text-black' : 'text-gray-500 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-800'}`}>{f.label}</button>
                                ))}
                                {SMART_LISTS.map(list => (
                                     <button key={list.id} onClick={() => { setActiveSmartList(list.id === activeSmartList ? null : list.id); setActiveFilter('all'); }} className={`px-4 py-1.5 rounded-full text-sm font-medium transition-colors whitespace-nowrap flex items-center gap-2 ${activeSmartList === list.id ? 'bg-indigo-600 text-white' : 'text-gray-500 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-800'}`}><list.icon size={14}/> {list.label}</button>
                                ))}
                            </div>
                        </div>

                        {/* Movies Grid */}
                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-x-6 gap-y-10">
                            {filteredItems.map(item => (
                                <div key={item.imdbID} onClick={() => setSelectedMovie(item)} className="group relative bg-white dark:bg-dark-card rounded-xl overflow-hidden shadow-lg hover:scale-[1.02] transition-all cursor-pointer border border-light-border dark:border-dark-border">
                                    <div className="relative aspect-[2/3] overflow-hidden bg-gray-900">
                                        <img src={getHighResPoster(item.Poster, 400)} className="w-full h-full object-cover opacity-90 group-hover:opacity-100 transition-opacity" loading="lazy" />
                                        <div className="absolute top-2 right-2 flex flex-col gap-1 items-end">
                                             {item.userMeta?.status === 'watched' && <span className="bg-green-500/90 text-white text-[10px] font-bold px-2 py-1 rounded-md shadow-lg"><CheckCircle size={10} /></span>}
                                        </div>
                                        {item.userMeta?.ratings?.overall > 0 && <div className="absolute bottom-2 left-2 bg-yellow-500 text-white px-1.5 py-0.5 rounded text-xs font-bold flex items-center gap-1 shadow-lg"><Star size={10} fill="currentColor" /> {item.userMeta.ratings.overall}</div>}
                                    </div>
                                    <div className="p-3">
                                        <h3 className="text-gray-900 dark:text-white font-bold text-sm line-clamp-1">{item.Title}</h3>
                                        <div className="text-[10px] text-gray-500 dark:text-gray-400 flex justify-between mt-1"><span>{item.Year}</span><span>{item.Type === 'series' ? 'TV' : 'Movie'}</span></div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </main>

                     {/* Detail Modal (Simplified for size) */}
                     {selectedMovie && (
                         <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-md">
                             <div className="bg-white dark:bg-dark-card w-full max-w-lg p-6 rounded-2xl relative">
                                 <button onClick={() => setSelectedMovie(null)} className="absolute top-4 right-4 text-gray-500"><X/></button>
                                 <h2 className="text-2xl font-bold dark:text-white mb-4">{selectedMovie.Title}</h2>
                                 <p className="text-gray-600 dark:text-gray-300 mb-4">{selectedMovie.Plot}</p>
                                 
                                 {/* Example of editable field */}
                                 <div className="mb-4">
                                     <label className="block text-xs font-bold uppercase text-gray-500 mb-1">Status</label>
                                     <div className="flex gap-2">
                                        <button onClick={() => updateItem(selectedMovie.imdbID, i => ({...i, userMeta: {...i.userMeta, status: 'watched'}}))} className={`flex-1 py-2 rounded border text-sm font-bold ${selectedMovie.userMeta?.status === 'watched' ? 'bg-green-500 text-white' : 'dark:text-white'}`}>Watched</button>
                                        <button onClick={() => updateItem(selectedMovie.imdbID, i => ({...i, userMeta: {...i.userMeta, status: 'watchlist'}}))} className={`flex-1 py-2 rounded border text-sm font-bold ${selectedMovie.userMeta?.status === 'watchlist' ? 'bg-blue-500 text-white' : 'dark:text-white'}`}>Watchlist</button>
                                     </div>
                                 </div>
                             </div>
                         </div>
                     )}

                    <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} apiKeys={apiKeys} setApiKeys={setApiKeys} theme={theme} setTheme={setTheme} 
                        onImport={handleImport}
                        onExport={handleExport}
                        onReset={async () => {
                          if (session) {
                             await supabase.from("vault_items").delete().eq("user_id", session.user.id);
                          }
                          setVault({ watched: {}, watchlist: {} });
                          localStorage.removeItem("vault_v6_data");
                        }}
                    />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>